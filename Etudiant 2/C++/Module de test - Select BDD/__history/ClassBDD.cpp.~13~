//---------------------------------------------------------------------------

#pragma hdrstop

#include "ClassBDD.h"
#include <windows.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#define HOST "192.168.65.79"
#define USER "msv"
#define PASSWORD "msv"
#define DATABASE "Projet_Cross"
//---------------------------------------------------------------------------
#pragma package(smart_init)

ClassBDD::ClassBDD(TMemo *Memo1)
{
  //constructeur
  result = NULL;
  this->Memo1 =Memo1;
}
ClassBDD::~ClassBDD()
{
  //destructeur
}

int ClassBDD::connectBDD()
{
	mySql = mysql_init(NULL);
	//std::stringstream stringbuilder;

	//Options de connexion
	//mysql_options(connect, MYSQL_READ_DEFAULT_GROUP, "option");

	//Si la connexion réussie...
	connect = mysql_real_connect(mySql, "HOST", "USER", "PASSWORD", "DATABASE", 0, NULL, 0); //("adresse de la BDD","identifiant BDD","mdp BDD","nom de la base",0,NULL,0)
	if (connect == NULL) {
		return 0;
	}
	else
	{
		return 1;
	}
}

void ClassBDD::closeBDD()
{
	//Fermeture de MySQL
	mysql_close(connect);
}

void ClassBDD::selectCourse()
{
try {
  // Les variables nécessaires à notre programme
  sql::Driver* driver;
  sql::Connection* con;
  sql::Statement* stmt;
  sql::ResultSet* res;

  // Etape 1 : créer une connexion à la BDD
  driver = get_driver_instance();
  // on note les paramètres classiques: adresse ip du serveur et port, login, mot de passe
  con = driver->connect("HOST", "USER", "PASSWORD");

  // Etape 2 : connexion à la base choisie, ici olivier_db
  con->setSchema("DATABASE");

  // Etape 3 : création d'un objet qui permet d'effectuer des requêtes sur la base
  stmt = con->createStatement();

  // Etape 4 : exécution d'une requete : ici on sélectionne tous les enregistrements
  // de la table Animal
  res = stmt->executeQuery("SELECT * FROM Course");

  // Etape 5 : exploitation du résultat de la requête
  while (res->next()) {
	Memo1->Lines->Add("\t... MySQL a repondu: ");
    // Acces par non du champ de la table : ici le champ 'id' que l'on recupère au format string
	Memo1->Lines->Add(res->getString("IdCourse"));
	Memo1->Lines->Add("\t... MySQL la suite : ");
    // Acces à la donnée par son numéro de colonne, 1 étant le premier (ici 'id'), 5 le nom de l'animal
	Memo1->Lines->Add(res->getString(5));
  }

  // On nettoie tout avant de sortir : effacement des pointeurs
  // le pointeur sur le Driver sera effacé tout seul
  delete res;
  delete stmt;
  delete con;

} catch (sql::SQLException &e) {
  // Gestion des execeptions pour déboggage
  Memo1->Lines->Add("# ERR: " << e.what());
  Memo1->Lines->Add(" (code erreur MySQL: " << e.getErrorCode());
  Memo1->Lines->Add(", EtatSQL: " << e.getSQLState() << " )");
}


// on sort en indiquant que tout c'est bien passé
return EXIT_SUCCESS;
}
}